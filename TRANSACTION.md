# Проектирование расширяемого API транзакционного слоя

## Цель задания

Разработать backend-прототип на TypeScript с акцентом на проектирование и реализацию расширяемого и удобного API работы с транзакциями БД, используя Kysely. Важна не только корректность, но и архитектурная продуманность, масштабируемость (при росте кодовой базы) и читаемость.

## Задачи:

1. **Создать макет TypeScript-приложения.**
- Можно использовать готовые шаблоны. Структура проекта и его организация должны отражать зрелый подход к проектированию backend-приложений. Предполагается, что в будущем приложение значительно вырастет.
- Реализовать два HTTP-эндпоинта:
    - Создание сообщения
    - Получение списка сообщений
2. **Реализовать универсальную функцию `withTransaction`, которая:**
- При первом вызове — запускает новую БД транзакцию (выполняет переданную функцию fn внутри неё).
- При повторном вызове в рамках уже начатой транзакции — переиспользует её.
- Передает транзакцию автоматически, чтобы можно было вызывать `withTransaction` без ручной передачи транзакции.
- Не передают транзакцию явно.
- Покрыта тестами.
3. **Продумать возможные расширения API**, которые сделают его удобным и масштабируемым в большом TypeScript-проекте.
- Внутри проекта, куда этот слой будет интегрирован, основная бизнес-логика реализована через классы (например, UserService, PaymentService и т. д.).
- Методы классов вызывают друг друга, и в текущей архитектуре не передают транзакцию явно.
- Разработчики хотят оборачивать методы в транзакции "автоматически", без потери читаемости или предсказуемости поведения.

Пример возможного использования (это не строгое требование, API проектируете вы, важно предоставить хороший DX):
```typescript
export async function mainFlow() {
  return withTransaction(async (trx) => {
    await trx.insertInto('users').values({ name: 'Alice' }).execute()

    // вызываем вложенную функцию, она не знает о текущей транзакции напрямую
    await logAction('Создан пользователь Alice')
  })
}

export async function logAction(message: string) {
  return withTransaction(async (trx) => {
    await trx.insertInto('logs').values({ message }).execute()
  })
}
```

### Ожидаемые минимальные технологии

- TypeScript
- Kysely
- Любой HTTP-сервер (Express, Fastify и др.)
- Любая БД (SQLite, Postgres и т.п.)
- Любая другая на ваш выбор.

### Вопросы на которые стоит ответить в конце записи видео или во время выполнения задачи.

- Сталкивались ли вы с подобным раньше?
- Как улучшить текущую реализацию?
- Напоминает ли что-то такой подход, если да то что?